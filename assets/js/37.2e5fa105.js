(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{203:function(t,e,s){"use strict";s.r(e);var a=s(0),i=Object(a.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("虚拟DOM本质上是JavaScript对象,是对真实DOM的抽象\n状态变更时，记录新树和旧树的差异\n最后把差异更新到真正的dom中\n"),s("a",{attrs:{href:"https://github.com/Advanced-Interview-Question/front-end-interview/blob/master/docs/guide/virtualDom.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("虚拟DOM"),s("OutboundLink")],1)])])])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#面试题","aria-hidden":"true"}},[this._v("#")]),this._v(" 面试题")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"谈谈mvvm的理解（mvc）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#谈谈mvvm的理解（mvc）","aria-hidden":"true"}},[this._v("#")]),this._v(" 谈谈mvvm的理解（mvc）")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"vue-响应式数据原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-响应式数据原理","aria-hidden":"true"}},[this._v("#")]),this._v(" vue 响应式数据原理")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"如何检测数组变化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何检测数组变化","aria-hidden":"true"}},[this._v("#")]),this._v(" 如何检测数组变化")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"为何采用异步渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为何采用异步渲染","aria-hidden":"true"}},[this._v("#")]),this._v(" 为何采用异步渲染")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"nexttick实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nexttick实现原理","aria-hidden":"true"}},[this._v("#")]),this._v(" nextTick实现原理")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"v-for-为什么不能和v-if一起用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-for-为什么不能和v-if一起用","aria-hidden":"true"}},[this._v("#")]),this._v(" v-for 为什么不能和v-if一起用")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[this._v("TIP")]),this._v(" "),e("p",[this._v("for 优先级比if高， 为了保证性能")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"keep-alive-原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive-原理","aria-hidden":"true"}},[this._v("#")]),this._v(" keep-alive 原理")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[this._v("TIP")]),this._v(" "),e("p",[this._v("其实就是在created时将需要缓存的VNode节点保存在this.cache中／在render时,如果VNode的name符合在缓存条件（可以用include以及exclude控制），则会从this.cache中取出之前缓存的VNode实例进行渲染。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"v-show-v-if"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-show-v-if","aria-hidden":"true"}},[this._v("#")]),this._v(" v-show v-if")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[this._v("TIP")]),this._v(" "),e("p",[this._v("v-show 其实就是自定义指令 directive， 而v-if 是经过template编译ast语法树（with）vNode，vm.patch函数通过虚拟DOM算法利用VNODE节点创建真实DOM节点。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"computed-watch、"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed-watch、","aria-hidden":"true"}},[this._v("#")]),this._v(" computed watch、")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[this._v("TIP")]),this._v(" "),e("p",[this._v("computedd 是有缓存的，是懒的， 默认不执行方法， 只要依赖的属性不发生变化就不会重新触发渲染视图，\nwatch 他们的原理都是内部创建了一个watcher")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"watch中的deep：-true是如何实现的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#watch中的deep：-true是如何实现的","aria-hidden":"true"}},[this._v("#")]),this._v(" watch中的deep： true是如何实现的")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[this._v("TIP")]),this._v(" "),e("p",[this._v("如果当前监控的值是数组类型， 会对对象中的每一项进行求职， 此时会将当前的watcher存入到对应的属性依赖中， 这样数组这种对象发生变化后会通知数据更新，\n如果是对象 循环递归存到watcher里")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"虚拟dom的优劣如何"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom的优劣如何","aria-hidden":"true"}},[this._v("#")]),this._v(" 虚拟DOM的优劣如何?")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("优点:")]),t._v(" "),s("p",[t._v("保证性能下限: 虚拟DOM可以经过diff找出最小差异,然后批量进行patch,这种操作虽然比不上手动优化,但是比起粗暴的DOM操作性能要好很多,因此虚拟DOM可以保证性能下限\n无需手动操作DOM: 虚拟DOM的diff和patch都是在一次更新中自动进行的,我们无需手动操作DOM,极大提高开发效率\n跨平台: 虚拟DOM本质上是JavaScript对象,而DOM与平台强相关,相比之下虚拟DOM可以进行更方便地跨平台操作,例如服务器渲染、移动端开发等等")]),t._v(" "),s("p",[t._v("缺点:")]),t._v(" "),s("p",[t._v("无法进行极致优化: 在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化,比如VScode采用直接手动操作DOM的方式进行极端的性能优化")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"虚拟dom实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom实现原理","aria-hidden":"true"}},[this._v("#")]),this._v(" 虚拟DOM实现原理?")])}],!1,null,null,null);e.default=i.exports}}]);